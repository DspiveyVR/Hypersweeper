import { getStopwatch, formatTime } from "./Stopwatch.js";

const sideLengthPx = window.innerWidth * 0.12;
const sideLengthBlocks = 8;
const blockSidePx = sideLengthPx / sideLengthBlocks;
const boardDimensions = 4;
const TOTAL_BOMBS = 18;
const stopwatchDisplay = document.getElementById('stopwatch');
const stopwatch = getStopwatch(stopwatchDisplay);
let scores = [];

const themes = {
  BlackAndWhite: 'BlackAndWhite',
  Default: 'Default'
};

let selectedTheme = themes.Default;

const mineImg = document.getElementById('mine');
const flagImg = document.getElementById('flag');
mineImg.src = `./Assets/${selectedTheme}/mine.png`;
flagImg.src = `./Assets/${selectedTheme}/flag.png`;

let trueBombCount = 0;
let displayedBombCount = 0;
const bombCountDisplay = document.getElementById('bombCount');
const bombCountImg = document.getElementById('bombCountImg');
bombCountImg.src = `./Assets/${selectedTheme}/mine.png`;


const deepCopy = obj => JSON.parse(JSON.stringify(obj));

const findAdjacentBombs = (squares, coords) => {
  let adjacentBombs = 0;
  for (let w = coords[3] - 1; w < coords[3] + 2; w++) {
    for (let z = coords[2] - 1; z < coords[2] + 2; z++) {
      for (let y = coords[1] - 1; y < coords[1] + 2; y++) {
        for (let x = coords[0] - 1; x < coords[0] + 2; x++) {
          try {
            adjacentBombs = squares[w][z][y][x].hasBomb ? adjacentBombs + 1 : adjacentBombs;
          } catch (error) { error;}
        }
      }
    }
  }
  return adjacentBombs;
};

const getPlane = () => {
    const getSquareRow = () => Array.from({ length: sideLengthBlocks }, () => ({
        hasBomb: false,
        isHidden: true,
        adjacentCount: 0
    }));
    return Array.from({ length: sideLengthBlocks }, () => getSquareRow());
};

const constructSquareArray = dimensions => {
    return dimensions !== 2
        ? Array.from({ length: boardDimensions }, () => constructSquareArray(dimensions - 1))
        : getPlane();
};

/**
 * GENERATED BY GEMINI
 * Shuffles an array in place using the Fisher-Yates algorithm.
 * @param {Array<any>} array - The array to shuffle.
 */
const shuffle = (array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}

/**
 * GENERATED BY GEMINI
 * Distributes a fixed number of bombs randomly across the 4D array.
 * @param {Array<any>} squares - The 4D array of square objects.
 */
const distributeBombs = (squares) => {
    // 1. Create an array of all possible coordinates [l, k, j, i]
    const allCoords = [];
    
    // Outer loops for 4D array (i=D3, j=D2, k=D1, l=D0)
    for (let i = 0; i < boardDimensions; i++) { // 4th dimension (planeRow)
        for (let j = 0; j < boardDimensions; j++) { // 3rd dimension (plane)
            for (let k = 0; k < sideLengthBlocks; k++) { // 2nd dimension (row)
                for (let l = 0; l < sideLengthBlocks; l++) { // 1st dimension (square)
                    // Store the coordinate tuple
                    allCoords.push([l, k, j, i]); 
                }
            }
        }
    }

    // 2. Shuffle the coordinates to randomize the selection
    shuffle(allCoords);

    // 3. Select the first TOTAL_BOMBS coordinates and assign bombs
    const bombCoords = allCoords.slice(0, TOTAL_BOMBS);

    bombCoords.forEach(coords => {
        const [l, k, j, i] = coords;
        // Access the square using the coordinates
        squares[i][j][k][l].hasBomb = true;
    });
};

const getInitialSquares = dimensions => {
    const squares = constructSquareArray(dimensions);

    distributeBombs(squares);

    for (let i = 0; i < boardDimensions; i++) {
        const planeRow = squares[i];
        for (let j = 0; j < boardDimensions; j++) {
            const plane = planeRow[j];
            for (let k = 0; k < sideLengthBlocks; k++) {
                const row = plane[k];
                for (let l = 0; l < sideLengthBlocks; l++) {
                    const sq = row[l];
                    sq.adjacentCount = findAdjacentBombs(squares, [l, k, j, i]);
                }
            }
        }
    }

    return squares;
}

const onHover = (e, canvas, highlighted, z, w) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  if (mouseX < 0 || mouseY < 0) {
      return;
  }
  const squareX = Math.floor(mouseX / blockSidePx);
  const squareY = Math.floor(mouseY / blockSidePx);

  highlighted.x = squareX;
  highlighted.y = squareY;
  highlighted.z = z;
  highlighted.w = w;
};
    
const getIsAdjacent = (x, y, z, w, highlighted) => 
  x >= (highlighted.x - 1) && x <= (highlighted.x + 1) &&
  y >= (highlighted.y - 1) && y <= (highlighted.y + 1) &&
  z >= (highlighted.z - 1) && z <= (highlighted.z + 1) &&
  w >= (highlighted.w - 1) && w <= (highlighted.w + 1);

const draw = (ctx, squares, highlighted, z, w) => {
  ctx.lineWidth = 2;

  ctx.clearRect(0, 0, sideLengthPx, sideLengthPx);


  for (let y = 0; y < sideLengthBlocks; y++) {
    for (let x = 0; x < sideLengthBlocks; x++) {
      let img = null;
      const currentSquare = squares[w][z][y][x];
      if (getIsAdjacent(x, y, z, w, highlighted)) {
        ctx.strokeStyle = '#7593ffff';
      } else {
        ctx.strokeStyle = '#c2c2c2ff';
      }

      if (currentSquare.isHidden) {
        ctx.fillStyle = '#313131ff';
      } else {
        ctx.fillStyle = '#c5c5c5ff';
        if (currentSquare.hasBomb) {
          img = mineImg;
        } 
      }
      if (currentSquare.hasFlag) {
        ctx.fillStyle = '#c5c5c5ff';
        img = flagImg;
      }
      ctx.fillRect(x * blockSidePx, y * blockSidePx, blockSidePx, blockSidePx);
      ctx.strokeRect(x * blockSidePx, y * blockSidePx, blockSidePx, blockSidePx);
      if (currentSquare.adjacentCount > 0 && !currentSquare.isHidden && !currentSquare.hasBomb) {
        ctx.fillStyle = '#004cafff';
        ctx.fillText(currentSquare.adjacentCount.toString(), x * blockSidePx + 2, (y + 1) * blockSidePx - 2);
      }
      if (img) {
        ctx.drawImage(img, x * blockSidePx, y * blockSidePx, blockSidePx, blockSidePx);
      }
    }
  };

  // window.requestAnimationFrame(() => draw(ctx, squares, highlighted))
};

const drawAllLoop = (squares, highlighted, canvases, gameOver) => {
  canvases.forEach((canvasRow, w) => {
    canvasRow.forEach((canvas, z) => {
      draw(canvas.ctx, squares, highlighted, z, w);
    });
  });

  if (!gameOver.restarting) {
    window.requestAnimationFrame(() => drawAllLoop(squares, highlighted, canvases, gameOver));
  }
};

// const getInitialSquares = () => {
//   return Array.from({length: BOARD_SIDE}, () => getPlane());
// };
const clearSquareWithAdjacent = (x, y, z, w, newSquares) => {
  if (!newSquares[w][z][y][x].hasFlag) { 
    newSquares[w][z][y][x].isHidden = false;
  }

  if (newSquares[w][z][y][x].adjacentCount == 0) {

    for (let i = w - 1; i < w + 2; i++) {
      for (let j = z - 1; j < z + 2; j++) {
        for (let k = y - 1; k < y + 2; k++) {
          for (let l = x - 1; l < x + 2; l++) {
            if (newSquares[i] && newSquares[i][j] && newSquares[i][j][k] && newSquares[i][j][k][l] && !newSquares[i][j][k][l].visited) {
              newSquares[i][j][k][l].visited = true;
              if (newSquares[i][j][k][l].adjacentCount == 0) {
                clearSquareWithAdjacent(l, k, j, i, newSquares);
              } else {
                if (!newSquares[i][j][k][l].hasFlag) {
                  newSquares[i][j][k][l].isHidden = false;
                }
              }
            }
          }
        }
      }
    }
  }
};

const handleSquareClick = (x, y, z, w, squares) => {
  const newSquares = deepCopy(squares).map(planeRow => planeRow.map(plane => plane.map(row => row.map(sq => { return { ...sq, visited: false }}))));
  clearSquareWithAdjacent(x, y, z, w, newSquares);

  squares.length = 0;
  newSquares.forEach(sq => squares.push(sq));
};

const updateScoreboard = () => {
  document.getElementById('scoreList')?.remove();

  const scoreList = document.createElement('ol');
  scoreList.id = 'scoreList';
  scores.forEach(score => {
    const sc = document.createElement('li');
    sc.innerText = formatTime(score);
    scoreList.appendChild(sc);
  });

  document.getElementById('scoreboard').appendChild(scoreList);
};

const onClick = (e, canvas, squares, z, w, firstClickDone, gameOver) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    if (mouseX < 0 || mouseY < 0) {
        return;
    }
    const squareX = Math.floor(mouseX / blockSidePx);
    const squareY = Math.floor(mouseY / blockSidePx);

    const getUnclearedSquares = () => squares.reduce((a, pr) => a + pr.reduce((b, pl) => b + pl.reduce((c, row) => c + row.reduce((d, sq) => 
      d + (!sq.hasBomb && sq.isHidden ? 1 : 0), 0), 0), 0), 0);


    if (gameOver.gameOver) {
      gameOver.restarting = true;
      stopwatch.reset();
      stopwatch.start();
      document.getElementById('gameOver').style.display = 'none';
      init();
      return;
    }

    if (squares[w][z][squareY][squareX].hasFlag) {
      return;
    }

    if (squares[w][z][squareY][squareX].hasBomb) {
      if (firstClickDone.state) {
        gameOver.gameOver = true;
        stopwatch.stop();
        const gameOverText = document.getElementById('gameOver');
        gameOverText.style.display = 'block';
        gameOverText.style.color = 'red';
        gameOverText.innerText = 'Game Over';
        squares.forEach(planeRow => 
          planeRow.forEach(plane => 
            plane.forEach(row => 
              row.forEach(sq => sq.isHidden = false)
            )
          )
        );
        return;
      } else {
        squares[w][z][squareY][squareX].hasBomb = false;
      }
    }

    firstClickDone.state = true;
    handleSquareClick(squareX, squareY, z, w, squares);

    if (getUnclearedSquares() == 0) {
      gameOver.gameOver = true;
      gameOver.win = true;
      stopwatch.stop();
      scores = [...scores, stopwatch.getElapsedtime()].sort();
      updateScoreboard();
      const gameOverText = document.getElementById('gameOver');
      gameOverText.style.display = 'block';
      gameOverText.style.color = 'green';
      gameOverText.innerText = 'You Win!';
    }
};

const placeFlag = (e, canvas, squares, z, w) => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  if (mouseX < 0 || mouseY < 0) {
      return;
  }
  const squareX = Math.floor(mouseX / blockSidePx);
  const squareY = Math.floor(mouseY / blockSidePx);

  if (squares[w][z][squareY][squareX].isHidden) {
    squares[w][z][squareY][squareX].hasFlag = !squares[w][z][squareY][squareX].hasFlag; // Inverts the state of the flag
    if (squares[w][z][squareY][squareX].hasFlag) {
      displayedBombCount--;
    } else {
      displayedBombCount++;
    }
    bombCountDisplay.innerText = displayedBombCount;
  }
};

const buildHtml = (squares, highlighted, firstClickDone, gameOver) => {
  const boardDiv = document.createElement('div');
  boardDiv.id = 'board';
  const canvases = [];

  squares.forEach((planeRow, w) => {
    const canvasRow = [];
    const planeRowDiv = document.createElement('div');
    planeRowDiv.id = `planeRow ${w}`;
    planeRowDiv.className = 'planeRow';

    planeRow.forEach((_, z) => {
      const canvas = document.createElement('canvas');
      canvas.addEventListener('mousemove', e => onHover(e, canvas, highlighted, z, w));
      canvas.addEventListener('click', e => onClick(e, canvas, squares, z, w, firstClickDone, gameOver), true);
      canvas.addEventListener('contextmenu', e => placeFlag(e, canvas, squares, z, w), true);
      canvas.setAttribute('width', sideLengthPx);
      canvas.setAttribute('height', sideLengthPx);
      canvas.id = `plane ${z}, ${w}`;
      const ctx = canvas.getContext('2d');
      ctx.font = `${blockSidePx * 0.6}px serif`

      planeRowDiv.appendChild(canvas);
      canvasRow.push({canvas, ctx})
    });

    boardDiv.appendChild(planeRowDiv);
    canvases.push(canvasRow);
  });

  return {canvases, boardDiv};
};

const init = () => {
  document.getElementById('board')?.remove();

  const squares = getInitialSquares(boardDimensions);
  const highlighted = {};
  let firstClickDone = { state: false };
  let gameOver = { gameOver: false, restarting: false, win: false };
  const { canvases, boardDiv } = buildHtml(squares, highlighted, firstClickDone, gameOver);
  document.body.appendChild(boardDiv);

  const getBombCount = () => squares.reduce((a, pr) => a + pr.reduce((b, pl) => b + pl.reduce((c, row) => c + row.reduce((d, sq) => d + (sq.hasBomb ? 1 : 0), 0), 0), 0), 0);
  trueBombCount = getBombCount();
  displayedBombCount = trueBombCount;
  bombCountDisplay.innerText = displayedBombCount;

  drawAllLoop(squares, highlighted, canvases, gameOver);
}

(() => {
  const cursor = document.getElementById('cursor');
  cursor.style.width = window.innerWidth * 0.01 + 'px';
  cursor.style.height = window.innerWidth * 0.01 + 'px';
  document.addEventListener('mousemove', e => { cursor.style.left = e.clientX + 'px'; cursor.style.top = e.clientY + 'px'; });
  const mainMenu = document.getElementById('mainMenu');
  mainMenu.addEventListener('click', () => {
    mainMenu.style.opacity = '0';
    setTimeout(() => {
      mainMenu.style.display = 'none';
      stopwatch.start();
    }, 500);
  });
  init();
})();
